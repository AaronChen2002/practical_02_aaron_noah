Binary Search â— List must be sorted before â— Look through by cutting list in half every Tim Linear Search â— List does not need to be sorted â— Look through like looking for word in dictionary, one by one Arrays (Sorted by specialVal) â— Search (Fast): You can use binary search (like searching a word in a dictionary) to quickly find a value. This takes about O(log n) time. â— Insert (Slow): Adding new records is slow because the array needs to stay sorted, requiring you to shift other records. This takes about O(n) time â— Real-World Example: Think of an alphabetically sorted class roster. Finding a student's name is fast, but adding a new name in the right spot takes more time â— Ex. [2, 4, 5, 7, 10] Linked Lists (Sorted by specialVal) â— Search (Slow): You have to go one record at a time to find what you're looking for (O(n) time). â— Insert (Fast): Adding a new record is easy because you just adjust the pointers (O(1) or O(n) time). â— Real-World Example: Think of a sign-up sheet where names are added as people arrive. Adding is easy, but finding someoneâ€™s name takes time â— Ex. 2 â†’ 4 â†’ 7 â†’ 10 Arrays vs linked lists â— Use arrays for fast searching and linked lists for fast inserting. Binary Search Tree (BST) combines the best parts of arrays and linked lists â— Search (Fast): You donâ€™t have to scan everything; you follow branches like a decision tree (O(log n) time). â— Insert (Balanced): Adding new records is also efficient because you just add them in the right spot in the tree (O(log n) time â— How It Works: â— Start at the top of the tree. â— If the value youâ€™re looking for is smaller, go left. â€¢ â€¢ If itâ€™s larger, go right BST Property â— For every node x in a Binary Search Tree: â— All nodes in the left subtree of x have keys smaller than the key at x. â— All nodes in the right subtree of x have keys greater than the key at xâ— Ex. â— Imagine you're organizing books on a shelf: â— The middle book is your current node (x). â— All books to the left are alphabetically earlier (smaller keys). â— All books to the right are alphabetically later (greater keys) â— Each node in a BST has: â— p â€“ A pointer to its parent node. â— left â€“ A pointer to its left child node. â— right â€“ A pointer to its right child node. â— key â€“ The value or data stored in the node Traversal in nodes of BST â— Traversal strategies differ by the ordering of the objects to visit â— Goal of traversal is to visit every node (search is to find a specific node) â— Inorder â— Left, current, right â— Preorder â— Current, left, right â— Postorder â— Left, right, current â— Inorder: â— 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 19, 20 â— Preorder â— 7, 4, 2, 3, 6, 5, 12, 9, 8, 11, 19, 15, 20 â— Postorder â— 3, 2, 5, 6, 4, 8, 11, 9, 15, 20, 19, 12, 7 Searching â— If the key matches: ğŸ¯ You're done! The search is successful. â— If the key is smaller: ğŸ” Look in the left subtree because all smaller keys are on the left. â— If the key is larger: ğŸ” Look in the right subtree because all larger keys are on the right Deletion 3 possible scenarios: 1. Node has no children (Leaf Node): Simply remove the node. 2. Node has one child: Remove the node and replace it with its child. 3. Node has two children: Replace the node with either: â— The inorder successor (smallest node in the right subtree), or â— The inorder predecessor (largest node in the left subtree) Balancing â— AVL Trees ensure that the balance factor (difference between heights of the left and right subtrees of any node) is always -1, 0, or 1. â— Left left and right right: single rotation â— Left right and right left: double rotationâ— A rotates clockwise around B â— Everything else rearranges based off of B being new parentâ€¦ â— T2.L gets assigned to A, not B because its smaller than B and therefore must be on the left side of it (its on left side originally) B+ Trees It ensures that all leaf nodes are at the same level and maintains a high branching factor, meaning each node can have many children Properties â— Root Node: Has at least 2 children (unless itâ€™s a leaf). â— Internal Nodes: Have between âŒˆm/2âŒ‰ and m children (m is the tree order). â— Leaf Nodes: All leaf nodes are at the same leve How B-Tree Works: â— Search: Perform a binary search within a node, and follow the appropriate child pointer. â— Insertion: Insert data into a node. If it overflows, split the node and promote the middle key to the parent. â— Deletion: Remove data, potentially merging nodes if they fall below the utilization threshold B+ Tree â— Refined version of the B-Tree, designed to improve range queries and make disk operations even more efficient. B- VS B+ Tree B-Tree: Think of it like an index in a book, where data (content) is sprinkled throughout the pages (nodes). B+ Tree: Think of it as an index at the start (internal nodes) that points directly to content chapters (leaf nodes), and the chapters are all linked together for quick scanning â— Internal nodes in a B+ Tree act like a directory for data in leaf nodes, improving lookup and traversal speeds. Inserting into B+ Tree 1. Find the Correct Leaf Node â— Start at the root node and follow the correct child pointers based on the key being inserted. â— Repeat until you reach the leaf node where the new key belongs. 2. Insert the Key into the Leaf Node â— If thereâ€™s space in the leaf node: â— Add the key in sorted order. â— If the leaf node is full: â— Split the leaf node into two nodes. â— The middle key is promoted to the parent node as a separator. 3. Handle Parent Node Overflow (If Any)â— If the parent node becomes full after promoting the middle key: â— Split the parent node and promote its middle key further up the tree. â— Repeat this process recursively until no node overflows or until the root node is split. 4. Update Links Between Leaf Nodes â— Ensure the leaf nodes remain doubly linked after the split for efficient range traversal