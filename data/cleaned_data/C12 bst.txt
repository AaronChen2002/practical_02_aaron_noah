Chapter 12: Binary Search Trees A binary search tree is a binary tree with a special property called the BST-property, which is given as follows: ? For all nodes x and y, if y belongs to the left subtree of x, then the key at y is less than the key at x, and if y belongs to the right subtree of x, then the key at y is greater than the key at x. We will assume that the keys of a BST are pairwise distinct. Each node has the following attributes: (cid:15) p, left, and right, which are pointers to the parent, the left child, and the right child, respectively, and (cid:15) key, which is key stored at the node. 1An example 7 4 12 2 6 9 19 3 5 8 11 15 20 2Traversal of the Nodes in a BST By \traversal" we mean visiting all the nodes in a graph. Traversal strategies can be speci(cid:12)ed by the ordering of the three objects to visit: the current node, the left subtree, and the right subtree. We assume the the left subtree always comes before the right subtree. Then there are three strategies. 1. Inorder. The ordering is: the left subtree, the current node, the right subtree. 2. Preorder. The ordering is: the current node, the left subtree, the right subtree. 3. Postorder. The ordering is: the left subtree, the right subtree, the current node. 3Inorder Traversal Pseudocode This recursive algorithm takes as the input a pointer to a tree and executed inorder traversal on the tree. While doing traversal it prints out the key of each node that is visited. Inorder Walk - (x) nil 1: if x = then return Inorder Walk 2: - (left[x]) 3: Print key[x] Inorder Walk 4: - (right[x]) We can write a similar pseudocode for preorder and postorder. 42 1 3 1 3 2 3 1 2 inorder preorder postorder 7 4 12 2 6 9 19 3 5 8 11 15 20 What is the outcome of inorder traversal on this BST? How about postorder traversal and preorder traversal? 5Inorder traversal gives: 2, 3, 4, 5, 6, 7, 8 , 9, 11, 12, 15, 19, 20. Preorder traversal gives: 7, 4, 2, 3, 6, 5, 12, 9, 8, 11, 19, 15, 20. Postorder traversal gives: 3, 2, 5, 6, 4, 8, 11, 9, 15, 20, 19, 12, 7. So, inorder travel on a BST (cid:12)nds the keys in nondecreasing order! 6Operations on BST 1. Searching for a key We assume that a key and the subtree in which the key is searched for are given as an input. We’ll take the full advantage of the BST-property. Suppose we are at a node. If the node has the key that is being searched for, then the search is over. Otherwise, the key at the current node is either strictly smaller than the key that is searched for or strictly greater than the key that is searched for. If the former is the case, then by the BST property, all the keys in th left subtree are strictly less than the key that is searched for. That means that we do not need to search in the left subtree. Thus, we will examine only the right subtree. If the latter is the case, by symmetry we will examine only the right subtree. 7Algorithm Here k is the key that is searched for and x is the start node. BST Search - (x, k) 1: y x nil 2: while y 6= do 3: if key[y] = k then return y 4: else if key[y] < k then y right[y] 5: else y left[y] 6: return (\NOT FOUND") 8An Example 7 search for 8 4 11 2 6 9 13 NIL What is the running time of search? 92. The Maximum and the Minimum To (cid:12)nd the minimum identify the leftmost node, i.e. the farthest node you can reach by following only left branches. To (cid:12)nd the maximum identify the rightmost node, i.e. the farthest node you can reach by following only right branches. BST Minimum - (x) nil 1: if x = then return (\Empty Tree") 2: y x nil 3: while left[y] 6= do y left[y] 4: return (key[y]) BST Maximum - (x) nil 1: if x = then return (\Empty Tree") 2: y x nil 3: while right[y] 6= do y right[y] 4: return (key[y]) 103. Insertion Suppose that we need to insert a node z such that k = key[z]. Using binary search we (cid:12)nd a nil such that replacing it by z does not break the BST-property. 11BST Insert - (x, z, k) nil 1: if x = then return \Error" 2: y x true 3: while do f 4: if key[y] < k 5: then z left[y] 6: else z right[y] nil 7: if z = break 8: g 9: if key[y] > k then left[y] z 10: else right[p[y]] z 124. The Successor and The Predecessor The successor (respectively, the predecessor) of a key k in a search tree is the smallest (respectively, the largest) key that belongs to the tree and that is strictly greater than (respectively, less than) k. The idea for (cid:12)nding the successor of a given node x. (cid:15) If x has the right child, then the successor is the minimum in the right subtree of x. (cid:15) Otherwise, the successor is the parent of the farthest node that can be reached from x by following only right branches backward. 13An Example 23 25 7 4 12 2 6 9 19 3 5 8 11 15 20 14Algorithm BST Successor - (x) nil 1: if right[x] 6= then 2: f y right[x] nil 3: while left[y] 6= do y left[y] 4: return (y) g 5: else 6: f y x 7: while right[p[x]] = x do y p[x] nil 8: if p[x] 6= then return (p[x]) 9: else return (\NO SUCCESSOR") g 15The predecessor can be found similarly with the roles of left and right exchanged and with the roles of maximum and minimum exchanged. For which node is the successor unde(cid:12)ned? What is the running time of the successor algorithm? 165. Deletion Suppose we want to delete a node z. 1. If z has no children, then we will just nil replace z by . 2. If z has only one child, then we will promote the unique child to z’s place. 3. If z has two children, then we will identify z’s successor. Call it y. The successor y either is a leaf or has only the right child. Promote y to z’s place. Treat the loss of y using one of the above two solutions. 178 8 5 11 5 11 1 6 9 13 1 6 9 13 3 7 10 3 10 2 4 2 4 8 8 5 11 5 11 1 6 9 13 3 6 9 13 3 7 10 2 4 7 10 2 4 8 9 5 11 5 11 1 6 9 13 1 6 10 13 3 7 10 3 2 4 2 4 18Algorithm This algorithm deletes z from BST T. BST Delete - (T, z) nil nil 1: if left[z] = or right[z] = 2: then y z BST Successor 3: else y - (z) 4: (cid:3) y is the node that’s actually removed. 5: (cid:3) Here y does not have two children. nil 6: if left[y] 6= 7: then x left[y] 8: else x right[y] 9: (cid:3) x is the node that’s moving to y’s position. nil 10: if x 6= then p[x] p[y] 11: (cid:3) p[x] is reset If x isn’t NIL. 12: (cid:3) Resetting is unnecessary if x is NIL. 19Algorithm (cont’d) nil 13: if p[y] = then root[T] x 14: (cid:3) If y is the root, then x becomes the root. 15: (cid:3) Otherwise, do the following. 16: else if y = left[p[y]] 17: then left[p[y]] x 18: (cid:3) If y is the left child of its parent, then 19: (cid:3) Set the parent’s left child to x. 20: else right[p[y]] x 21: (cid:3) If y is the right child of its parent, then 22: (cid:3) Set the parent’s right child to x. 23: if y 6= z then 24: f key[z] key[y] 25: Move other data from y to z g 27: return (y) 20Summary of E(cid:14)ciency Analysis Theorem A On a binary search tree of Search Minimum Maximum height h, , , , Successor Predecessor Insert , , , and Delete can be made to run in O(h) time. 21Randomly built BST Suppose that we insert n distinct keys into an initially empty tree. Assuming that the n! permutations are equally likely to occur, what is the average height of the tree? To study this question we consider the process of constructing a tree T by inserting in order randomly selected n distinct keys to an initially empty tree. Here the actually values of the keys do not matter. What matters is the position of the inserted key in the n keys. 22The Process of Construction So, we will view the process as follows: A key x from the keys is selected uniformly at random and is inserted to the tree. Then all the other keys are inserted. Here all the keys greater than x go into the right subtree of x and all the keys smaller than x go into the left subtree. Thus, the height of the tree thus constructed is one plus the larger of the height of the left subtree and the height of the right subtree. 23Random Variables n = number of keys X = height of the tree of n keys n X Y = 2 n. n We want an upper bound on E[Y ]. n For n (cid:21) 2, we have n 1 0 1 E[Y ] = 2E[maxfY ; Y g] : n i(cid:0)1 n(cid:0)i n X @i=1 A E[maxfY ; Y g] (cid:20) E[Y + Y ] i(cid:0)1 n(cid:0)i i(cid:0)1 n(cid:0)i (cid:20) E[Y ] + E[Y ] i(cid:0)1 n(cid:0)i Collecting terms: n(cid:0)1 4 E[Y ] (cid:20) E[Y ]: n i n X i=1 24Analysis 1 n+3 We claim that for all n (cid:21) 1 E[Y ] (cid:20) . n 4(cid:16) 3 (cid:17) We prove this by induction on n. 0 Base case: E[Y ] = 2 = 1. 1 Induction step: We have n(cid:0)1 4 E[Y ] (cid:20) E[Y ] n i n X i=1 Using the fact that n(cid:0)1 i + 3 n + 3 = X (cid:16) 3 (cid:17) (cid:16) 4 (cid:17) i=0 4 1 n + 3 E[Y ] (cid:20) (cid:1) (cid:1) n (cid:16) (cid:17) n 4 4 1 n + 3 E[Y ] (cid:20) (cid:1) n (cid:16) (cid:17) 4 3 25Jensen’s inequality A function f is convex if for all x and y, x < y, and for all (cid:21), 0 (cid:20) (cid:21) (cid:20) 1, f((cid:21)x + (1 (cid:0) (cid:21))y) (cid:20) (cid:21)f(x) + (1 (cid:0) (cid:21))f(y) Jensen’s inequality states that for all random variables X and for all convex function f f(E[X]) (cid:20) E[f(X)]: x Let this X be X and f(x) = 2 . Then n E[f(X)] = E[Y ]. So, we have n 1 n + 3 E[X ] 2 n (cid:20) : (cid:16) (cid:17) 4 3 3 The right-hand side is at most (n + 3) . By taking the log of both sides, we have E[X ] = O(log n): n Thus the average height of a randomly build BST is O(log n). 26